package com.fortnite.pronos.config;

import java.time.Duration;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import jakarta.annotation.PostConstruct;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.HikariPoolMXBean;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import lombok.extern.slf4j.Slf4j;

/**
 * PHASE 3A - SPRINT 4: ADVANCED DATABASE MONITORING FOR 500+ USERS
 *
 * <p>Surveillance compl√®te: - Connection pool utilization pour primary et read-only - Slow query
 * detection et alerting - Read replica lag monitoring - Database performance metrics pour
 * Prometheus/Grafana - Health checks complets pour tous les datasources
 */
@Configuration
@EnableScheduling
@Slf4j
public class DatabaseMonitoringConfig {

  @Bean
  @ConditionalOnProperty(name = "spring.datasource.read-only.jdbc-url")
  public DatabaseMonitor databaseMonitor(
      MeterRegistry meterRegistry,
      @Qualifier("primaryDataSource") DataSource primaryDataSource,
      @Qualifier("readOnlyDataSource") DataSource readOnlyDataSource) {
    return new DatabaseMonitor(meterRegistry, primaryDataSource, readOnlyDataSource);
  }

  @Bean
  @ConditionalOnMissingBean(DatabaseMonitor.class)
  public DatabaseMonitor simpleDatabaseMonitor(MeterRegistry meterRegistry, DataSource dataSource) {
    return new DatabaseMonitor(meterRegistry, dataSource, dataSource);
  }

  @Bean
  @ConditionalOnProperty(name = "spring.datasource.read-only.jdbc-url")
  public DatabaseHealthIndicator databaseHealthIndicator(
      @Qualifier("primaryDataSource") DataSource primaryDataSource,
      @Qualifier("readOnlyDataSource") DataSource readOnlyDataSource) {
    return new DatabaseHealthIndicator(primaryDataSource, readOnlyDataSource);
  }

  @Bean
  @ConditionalOnMissingBean(DatabaseHealthIndicator.class)
  public DatabaseHealthIndicator simpleDatabaseHealthIndicator(DataSource dataSource) {
    return new DatabaseHealthIndicator(dataSource, dataSource);
  }

  @Component
  @Slf4j
  public static class DatabaseMonitor {

    private final MeterRegistry meterRegistry;
    private final HikariDataSource primaryDataSource;
    private final HikariDataSource readOnlyDataSource;

    // Metrics
    private final Timer primaryQueryTimer;
    private final Timer readOnlyQueryTimer;
    private final Counter slowQueryCounter;
    private final Counter connectionLeakCounter;

    @Value("${database.monitoring.slow-query-threshold:500ms}")
    private Duration slowQueryThreshold;

    @Value("${database.monitoring.connection-pool-alert-threshold:80}")
    private int connectionPoolAlertThreshold;

    public DatabaseMonitor(
        MeterRegistry meterRegistry, DataSource primaryDataSource, DataSource readOnlyDataSource) {
      this.meterRegistry = meterRegistry;
      this.primaryDataSource = (HikariDataSource) primaryDataSource;
      this.readOnlyDataSource =
          readOnlyDataSource != null ? (HikariDataSource) readOnlyDataSource : null;

      // Initialize metrics
      this.primaryQueryTimer =
          Timer.builder("database.query.duration")
              .tag("datasource", "primary")
              .description("Primary database query execution time")
              .register(meterRegistry);

      this.readOnlyQueryTimer =
          Timer.builder("database.query.duration")
              .tag("datasource", "readonly")
              .description("Read-only database query execution time")
              .register(meterRegistry);

      this.slowQueryCounter =
          Counter.builder("database.slow.queries")
              .description("Number of slow queries detected")
              .register(meterRegistry);

      this.connectionLeakCounter =
          Counter.builder("database.connection.leaks")
              .description("Number of connection leaks detected")
              .register(meterRegistry);
    }

    @PostConstruct
    public void setupMetrics() {
      // Primary datasource metrics
      setupDataSourceMetrics(primaryDataSource, "primary");

      // Read-only datasource metrics (if available)
      if (readOnlyDataSource != null) {
        setupDataSourceMetrics(readOnlyDataSource, "readonly");
      }

      log.info("üìä Database monitoring metrics initialized for 500+ users scaling");
    }

    private void setupDataSourceMetrics(HikariDataSource dataSource, String dsName) {
      HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();

      // Active connections
      Gauge.builder(
              "database.connections.active", poolMXBean, HikariPoolMXBean::getActiveConnections)
          .tag("datasource", dsName)
          .description("Active database connections")
          .register(meterRegistry);

      // Idle connections
      Gauge.builder("database.connections.idle", poolMXBean, HikariPoolMXBean::getIdleConnections)
          .tag("datasource", dsName)
          .description("Idle database connections")
          .register(meterRegistry);

      // Total connections
      Gauge.builder("database.connections.total", poolMXBean, HikariPoolMXBean::getTotalConnections)
          .tag("datasource", dsName)
          .description("Total database connections")
          .register(meterRegistry);

      // Threads awaiting connection
      Gauge.builder(
              "database.connections.pending",
              poolMXBean,
              HikariPoolMXBean::getThreadsAwaitingConnection)
          .tag("datasource", dsName)
          .description("Threads awaiting database connections")
          .register(meterRegistry);
    }

    /**
     * MONITORING CONTINU - Surveillance toutes les 30 secondes Optimis√© pour d√©tecter les probl√®mes
     * avant impact sur 500+ utilisateurs
     */
    @Scheduled(fixedRate = 30000) // 30 seconds
    public void monitorConnectionPools() {
      try {
        // Monitor primary datasource
        monitorDataSource(primaryDataSource, "PRIMARY");

        // Monitor read-only datasource if available
        if (readOnlyDataSource != null) {
          monitorDataSource(readOnlyDataSource, "READ-ONLY");
        }

      } catch (Exception e) {
        log.error("‚ùå Error during database monitoring: {}", e.getMessage());
      }
    }

    private void monitorDataSource(HikariDataSource dataSource, String name) {
      HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();

      int activeConnections = poolMXBean.getActiveConnections();
      int totalConnections = poolMXBean.getTotalConnections();
      int threadsAwaiting = poolMXBean.getThreadsAwaitingConnection();

      // Calculate utilization percentage
      double utilizationPercentage =
          totalConnections > 0 ? (double) activeConnections / totalConnections * 100 : 0;

      // Alert on high utilization
      if (utilizationPercentage > connectionPoolAlertThreshold) {
        log.warn(
            "üö® {} DATABASE POOL ALERT: {}% utilization ({}/{} connections) - {} threads waiting",
            name,
            String.format("%.1f", utilizationPercentage),
            activeConnections,
            totalConnections,
            threadsAwaiting);
      }

      // Alert on threads waiting
      if (threadsAwaiting > 0) {
        log.warn("‚è≥ {} DATABASE: {} threads waiting for connections", name, threadsAwaiting);
      }
    }

    /**
     * RAPPORT D√âTAILL√â - Toutes les 5 minutes Analyse approfondie des performances pour 500+
     * utilisateurs
     */
    @Scheduled(fixedRate = 300000) // 5 minutes
    public void detailedDatabaseReport() {
      try {
        log.info("üìä === DATABASE PERFORMANCE REPORT - 500+ USERS SCALING ===");

        // Primary database report
        generateDataSourceReport(primaryDataSource, "PRIMARY DB");

        // Read-only database report
        if (readOnlyDataSource != null) {
          generateDataSourceReport(readOnlyDataSource, "READ-ONLY DB");
        } else {
          log.info("üìñ READ-ONLY DB: Not configured (single-node deployment)");
        }

        // Query performance summary
        log.info(
            "‚ö° PRIMARY QUERIES: avg={}ms, count={}",
            String.format("%.2f", primaryQueryTimer.mean(TimeUnit.MILLISECONDS)),
            primaryQueryTimer.count());

        if (readOnlyDataSource != null) {
          log.info(
              "üìñ READ-ONLY QUERIES: avg={}ms, count={}",
              String.format("%.2f", readOnlyQueryTimer.mean(TimeUnit.MILLISECONDS)),
              readOnlyQueryTimer.count());
        }

        log.info(
            "üêå SLOW QUERIES: {} detected (threshold: {}ms)",
            slowQueryCounter.count(),
            slowQueryThreshold.toMillis());

        log.info("üìä === END DATABASE PERFORMANCE REPORT ===");

      } catch (Exception e) {
        log.error("‚ùå Error generating database report: {}", e.getMessage());
      }
    }

    private void generateDataSourceReport(HikariDataSource dataSource, String name) {
      HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();

      int active = poolMXBean.getActiveConnections();
      int idle = poolMXBean.getIdleConnections();
      int total = poolMXBean.getTotalConnections();
      int waiting = poolMXBean.getThreadsAwaitingConnection();

      double utilization = total > 0 ? (double) active / total * 100 : 0;

      log.info(
          "üîó {}: {}/{} connections ({}% util), {} idle, {} waiting",
          name, active, total, String.format("%.1f", utilization), idle, waiting);
    }

    /** Public methods pour enregistrer les m√©triques depuis les services */
    public Timer.Sample startPrimaryQueryTimer() {
      return Timer.start(meterRegistry);
    }

    public void stopPrimaryQueryTimer(Timer.Sample sample) {
      sample.stop(primaryQueryTimer);
    }

    public Timer.Sample startReadOnlyQueryTimer() {
      return Timer.start(meterRegistry);
    }

    public void stopReadOnlyQueryTimer(Timer.Sample sample) {
      sample.stop(readOnlyQueryTimer);
    }

    public void recordSlowQuery(Duration duration) {
      if (duration.compareTo(slowQueryThreshold) > 0) {
        slowQueryCounter.increment();
        log.warn(
            "üêå SLOW QUERY detected: {}ms (threshold: {}ms)",
            duration.toMillis(),
            slowQueryThreshold.toMillis());
      }
    }

    public void recordConnectionLeak() {
      connectionLeakCounter.increment();
      log.error("üíß CONNECTION LEAK detected!");
    }
  }

  /** HEALTH INDICATOR pour surveillance compl√®te des datasources */
  @Component
  public static class DatabaseHealthIndicator implements HealthIndicator {

    private final DataSource primaryDataSource;
    private final DataSource readOnlyDataSource;

    public DatabaseHealthIndicator(DataSource primaryDataSource, DataSource readOnlyDataSource) {
      this.primaryDataSource = primaryDataSource;
      this.readOnlyDataSource = readOnlyDataSource;
    }

    @Override
    public Health health() {
      try {
        Health.Builder health = Health.up();

        // Check primary database
        boolean primaryHealthy = checkDataSource(primaryDataSource, "primary");
        health.withDetail("primary-database", primaryHealthy ? "UP" : "DOWN");

        // Check read-only database if configured
        if (readOnlyDataSource != null) {
          boolean readOnlyHealthy = checkDataSource(readOnlyDataSource, "read-only");
          health.withDetail("read-only-database", readOnlyHealthy ? "UP" : "DOWN");

          if (!primaryHealthy || !readOnlyHealthy) {
            health.down();
          }
        } else {
          health.withDetail("read-only-database", "NOT_CONFIGURED");
          if (!primaryHealthy) {
            health.down();
          }
        }

        // Add connection pool details
        if (primaryDataSource instanceof HikariDataSource) {
          HikariPoolMXBean poolMXBean =
              ((HikariDataSource) primaryDataSource).getHikariPoolMXBean();
          health.withDetail("primary-pool-active", poolMXBean.getActiveConnections());
          health.withDetail("primary-pool-total", poolMXBean.getTotalConnections());
        }

        return health.build();

      } catch (Exception e) {
        return Health.down().withDetail("error", e.getMessage()).build();
      }
    }

    private boolean checkDataSource(DataSource dataSource, String name) {
      try (var connection = dataSource.getConnection()) {
        return connection.isValid(5); // 5 second timeout
      } catch (Exception e) {
        log.error("‚ùå Database health check failed for {}: {}", name, e.getMessage());
        return false;
      }
    }
  }
}
