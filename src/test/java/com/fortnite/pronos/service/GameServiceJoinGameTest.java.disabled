package com.fortnite.pronos.service;

import com.fortnite.pronos.dto.JoinGameRequest;
import com.fortnite.pronos.exception.GameFullException;
import com.fortnite.pronos.exception.GameNotFoundException;
import com.fortnite.pronos.exception.InvalidGameRequestException;
import com.fortnite.pronos.exception.InvalidGameStateException;
import com.fortnite.pronos.exception.UserAlreadyInGameException;
import com.fortnite.pronos.exception.UserNotFoundException;
import com.fortnite.pronos.model.*;
import com.fortnite.pronos.repository.GameParticipantRepository;
import com.fortnite.pronos.repository.GameRepository;
import com.fortnite.pronos.repository.UserRepository;
import com.fortnite.pronos.util.TestDataBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.time.LocalDateTime;
import java.util.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Tests TDD pour GameService.joinGame()
 * Clean Code : une classe de test par fonctionnalité majeure
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
@DisplayName("Tests TDD - GameService.joinGame()")
class GameServiceJoinGameTest {

    @Mock
    private GameRepository gameRepository;
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private GameParticipantRepository gameParticipantRepository;
    
    @Mock
    private ValidationService validationService;
    
    @Mock
    private InvitationCodeService invitationCodeService;
    
    @InjectMocks
    private RefactoredGameService refactoredGameService;
    
    private User thibaut;
    private User teddy;
    private User marcel;
    private Game testGame;
    private JoinGameRequest validRequest;
    
    @BeforeEach
    void setUp() {
        // Créer les utilisateurs de test
        thibaut = TestDataBuilder.createThibaut();
        thibaut.setId(UUID.randomUUID());
        
        teddy = TestDataBuilder.createTeddy();
        teddy.setId(UUID.randomUUID());
        
        marcel = TestDataBuilder.createMarcel();
        marcel.setId(UUID.randomUUID());
        
        // Créer une game de test
        testGame = TestDataBuilder.createValidGame(marcel, "Tournoi Fortnite");
        testGame.setId(UUID.randomUUID());
        testGame.setInvitationCode("ABC123");
        testGame.setMaxParticipants(4);
        
        // Créer une requête valide
        validRequest = new JoinGameRequest(testGame.getId(), teddy.getId());
    }
    
    // UC6.1 : Rejoindre via ID de game
    @Test
    @DisplayName("UC6.1 - Devrait permettre à Teddy de rejoindre la game de Marcel")
    void shouldAllowTeddyToJoinMarcelsGame() {
        // Given
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        when(gameParticipantRepository.existsByGameAndUser(testGame, teddy)).thenReturn(false);
        when(gameParticipantRepository.countByGame(testGame)).thenReturn(1L); // Marcel est déjà dedans
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        refactoredGameService.joinGame(teddy.getId(), validRequest);
        
        // Then
        // Vérifier que la méthode s'exécute sans exception
        verify(gameParticipantRepository).save(argThat(participant ->
            participant.getUser().equals(teddy) &&
            participant.getGame().equals(testGame) &&
            participant.getDraftOrder() == 2
        ));
    }
    
    // UC6.2 : Rejoindre via code d'invitation
    @Test
    @DisplayName("UC6.2 - Devrait permettre de rejoindre avec un code d'invitation")
    void shouldAllowJoinWithInvitationCode() {
        // Given
        JoinGameRequest requestWithCode = new JoinGameRequest();
        requestWithCode.setUserId(thibaut.getId());
        requestWithCode.setInvitationCode("ABC123");
        
        when(userRepository.findById(thibaut.getId())).thenReturn(Optional.of(thibaut));
        when(gameRepository.findByInvitationCode("ABC123")).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        when(invitationCodeService.isValidCodeFormat("ABC123")).thenReturn(true);
        when(gameParticipantRepository.existsByGameAndUser(testGame, thibaut)).thenReturn(false);
        when(gameParticipantRepository.countByGame(testGame)).thenReturn(1L);
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        refactoredGameService.joinGame(thibaut.getId(), requestWithCode);
        
        // Then
        // Vérifier que la méthode s'exécute sans exception
        verify(gameRepository).findByInvitationCode("ABC123");
    }
    
    // Validation : Game pleine
    @Test
    @DisplayName("Devrait rejeter si la game est pleine")
    void shouldRejectIfGameIsFull() {
        // Given
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        when(gameParticipantRepository.existsByGameAndUser(testGame, teddy)).thenReturn(false);
        when(gameParticipantRepository.countByGame(testGame)).thenReturn(4L); // Game pleine
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.joinGame(teddy.getId(), validRequest))
            .isInstanceOf(GameFullException.class)
            .hasMessageContaining("pleine");
    }
    
    // Validation : Utilisateur déjà dans la game
    @Test
    @DisplayName("Devrait rejeter si l'utilisateur est déjà dans la game")
    void shouldRejectIfUserAlreadyInGame() {
        // Given
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        when(gameParticipantRepository.existsByGameAndUser(testGame, marcel)).thenReturn(true);
        
        JoinGameRequest marcelRequest = new JoinGameRequest(testGame.getId(), marcel.getId());
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.joinGame(marcel.getId(), marcelRequest))
            .isInstanceOf(UserAlreadyInGameException.class)
            .hasMessageContaining("déjà dans la game");
    }
    
    // Validation : Game dans un mauvais état
    @Test
    @DisplayName("Devrait rejeter si la game n'est pas en état CREATING")
    void shouldRejectIfGameNotInCreatingState() {
        // Given
        testGame.setStatus(GameStatus.DRAFTING);
        
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.joinGame(teddy.getId(), validRequest))
            .isInstanceOf(InvalidGameStateException.class)
            .hasMessageContaining("pas ouverte aux inscriptions");
    }
    
    // Validation : Game non trouvée
    @Test
    @DisplayName("Devrait échouer si la game n'existe pas")
    void shouldFailIfGameNotFound() {
        // Given
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.empty());
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.joinGame(teddy.getId(), validRequest))
            .isInstanceOf(GameNotFoundException.class)
            .hasMessageContaining("Game non trouvée");
    }
    
    // Validation : Code d'invitation invalide
    @Test
    @DisplayName("Devrait rejeter un code d'invitation invalide")
    void shouldRejectInvalidInvitationCode() {
        // Given
        JoinGameRequest requestWithBadCode = new JoinGameRequest();
        requestWithBadCode.setUserId(teddy.getId());
        requestWithBadCode.setInvitationCode("INVALID");
        
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(invitationCodeService.isValidCodeFormat("INVALID")).thenReturn(false);
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.joinGame(teddy.getId(), requestWithBadCode))
            .isInstanceOf(InvalidGameRequestException.class)
            .hasMessageContaining("Code d'invitation invalide");
    }
    
    // Test d'intégration : Les 3 joueurs rejoignent la game
    @Test
    @DisplayName("Devrait permettre aux 3 joueurs de rejoindre successivement")
    void shouldAllowAll3PlayersToJoinSuccessively() {
        // Given - Marcel a créé la game
        List<GameParticipant> participants = new ArrayList<>();
        GameParticipant marcelParticipant = TestDataBuilder.createValidParticipant(testGame, marcel, 1);
        participants.add(marcelParticipant);
        
        // Teddy rejoint
        JoinGameRequest teddyRequest = new JoinGameRequest(testGame.getId(), teddy.getId());
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        when(gameParticipantRepository.existsByGameAndUser(testGame, teddy)).thenReturn(false);
        when(gameParticipantRepository.countByGame(testGame)).thenReturn(1L);
        when(gameParticipantRepository.save(any())).thenAnswer(invocation -> {
            GameParticipant saved = invocation.getArgument(0);
            participants.add(saved);
            return saved;
        });
        
        refactoredGameService.joinGame(teddy.getId(), teddyRequest);
        
        // Thibaut rejoint
        JoinGameRequest thibautRequest = new JoinGameRequest(testGame.getId(), thibaut.getId());
        when(userRepository.findById(thibaut.getId())).thenReturn(Optional.of(thibaut));
        when(gameParticipantRepository.existsByGameAndUser(testGame, thibaut)).thenReturn(false);
        when(gameParticipantRepository.countByGame(testGame)).thenReturn(2L);
        
        refactoredGameService.joinGame(thibaut.getId(), thibautRequest);
        
        // Then
        assertThat(participants).hasSize(3);
        
        // Vérifier l'ordre des participants
        assertThat(participants.get(0).getUser()).isEqualTo(marcel);
        assertThat(participants.get(0).getDraftOrder()).isEqualTo(1);
        assertThat(participants.get(1).getUser()).isEqualTo(teddy);
        assertThat(participants.get(1).getDraftOrder()).isEqualTo(2);
        assertThat(participants.get(2).getUser()).isEqualTo(thibaut);
        assertThat(participants.get(2).getDraftOrder()).isEqualTo(3);
    }
    
    // Performance
    @Test
    @DisplayName("Performance - Devrait rejoindre une game en moins de 100ms")
    void shouldJoinGameQuickly() {
        // Given
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(validationService.validateJoinGameRequest(any())).thenReturn(true);
        when(gameParticipantRepository.existsByGameAndUser(testGame, teddy)).thenReturn(false);
        when(gameParticipantRepository.countByGame(testGame)).thenReturn(1L);
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        long startTime = System.currentTimeMillis();
        refactoredGameService.joinGame(teddy.getId(), validRequest);
        long endTime = System.currentTimeMillis();
        
        // Then
        assertThat(endTime - startTime).isLessThan(100);
    }
} 