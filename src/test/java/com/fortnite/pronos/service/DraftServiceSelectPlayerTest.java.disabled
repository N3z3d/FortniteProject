package com.fortnite.pronos.service;

import com.fortnite.pronos.dto.DraftPickDto;
import com.fortnite.pronos.exception.*;
import com.fortnite.pronos.model.*;
import com.fortnite.pronos.repository.*;
import com.fortnite.pronos.service.draft.DraftService;
import com.fortnite.pronos.util.TestDataBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.time.LocalDateTime;
import java.util.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Tests TDD pour GameService.selectPlayer()
 * Clean Code : une classe de test par fonctionnalité majeure
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
@DisplayName("Tests TDD - GameService.selectPlayer()")
class DraftServiceSelectPlayerTest {

    @Mock
    private GameRepository gameRepository;
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private PlayerRepository playerRepository;
    
    @Mock
    private DraftRepository draftRepository;
    
    @Mock
    private DraftPickRepository draftPickRepository;
    
    @Mock
    private GameParticipantRepository gameParticipantRepository;
    
    @Mock
    private DraftService draftService;
    
    @InjectMocks
    private RefactoredGameService refactoredGameService;
    
    private User marcel;
    private User teddy;
    private User thibaut;
    private User sarah;
    private Game testGame;
    private Draft testDraft;
    private List<GameParticipant> participants;
    private Player aqua;
    private Player th0masHD;
    private Player rezon;
    private Player malibuca;
    
    @BeforeEach
    void setUp() {
        // Créer les utilisateurs
        marcel = TestDataBuilder.createMarcel();
        marcel.setId(UUID.randomUUID());
        
        teddy = TestDataBuilder.createTeddy();
        teddy.setId(UUID.randomUUID());
        
        thibaut = TestDataBuilder.createThibaut();
        thibaut.setId(UUID.randomUUID());
        
        sarah = TestDataBuilder.createSarah();
        sarah.setId(UUID.randomUUID());
        
        // Créer les joueurs Fortnite
        aqua = TestDataBuilder.createValidPlayer("Aqua", Player.Region.EU);
        aqua.setId(UUID.randomUUID());
        
        th0masHD = TestDataBuilder.createValidPlayer("Th0masHD", Player.Region.EU);
        th0masHD.setId(UUID.randomUUID());
        
        rezon = TestDataBuilder.createValidPlayer("Rezon", Player.Region.EU);
        rezon.setId(UUID.randomUUID());
        
        malibuca = TestDataBuilder.createValidPlayer("Malibuca", Player.Region.EU);
        malibuca.setId(UUID.randomUUID());
        
        // Créer une game en draft
        testGame = TestDataBuilder.createValidGame(marcel, "Draft en cours");
        testGame.setId(UUID.randomUUID());
        testGame.setStatus(GameStatus.DRAFTING);
        
        // Créer le draft
        testDraft = new Draft(testGame);
        testDraft.setId(UUID.randomUUID());
        testDraft.setStatus(Draft.Status.ACTIVE);
        testDraft.setCurrentRound(1);
        testDraft.setCurrentPick(1);
        testDraft.setTotalRounds(10);
        
        // Créer les participants avec ordre de draft
        participants = Arrays.asList(
            createParticipant(marcel, 1),
            createParticipant(teddy, 2),
            createParticipant(thibaut, 3),
            createParticipant(sarah, 4)
        );
    }
    
    private GameParticipant createParticipant(User user, int draftOrder) {
        GameParticipant participant = TestDataBuilder.createValidParticipant(testGame, user, draftOrder);
        participant.setId(UUID.randomUUID());
        return participant;
    }
    
    // UC8.1 : Sélection basique d'un joueur
    @Test
    @DisplayName("UC8.1 - Marcel devrait pouvoir sélectionner Aqua comme premier pick")
    void shouldAllowMarcelToSelectAquaAsFirstPick() {
        // Given
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua));
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(0)); // Marcel
        when(draftPickRepository.existsByDraftAndPlayer(testDraft, aqua)).thenReturn(false);
        when(draftPickRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(draftService.nextPick(any(), anyInt())).thenReturn(testDraft);
        
        // When
        DraftPickDto result = refactoredGameService.selectPlayer(marcel.getId(), testGame.getId(), aqua.getId());
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getPlayerName()).isEqualTo("Aqua");
        assertThat(result.getPickerName()).isEqualTo("Marcel");
        assertThat(result.getRound()).isEqualTo(1);
        assertThat(result.getPick()).isEqualTo(1);
    }
    
    // UC8.2 : Validation - Ce n'est pas le tour du joueur
    @Test
    @DisplayName("UC8.2 - Teddy ne devrait pas pouvoir picker quand c'est le tour de Marcel")
    void shouldRejectIfNotPlayerTurn() {
        // Given
        when(userRepository.findById(teddy.getId())).thenReturn(Optional.of(teddy));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua));
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(0)); // Marcel
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.selectPlayer(teddy.getId(), testGame.getId(), aqua.getId()))
            .isInstanceOf(NotYourTurnException.class)
            .hasMessageContaining("Ce n'est pas votre tour");
    }
    
    // UC8.3 : Validation - Joueur déjà sélectionné
    @Test
    @DisplayName("UC8.3 - Ne devrait pas pouvoir sélectionner un joueur déjà pris")
    void shouldRejectIfPlayerAlreadySelected() {
        // Given
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua));
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(0));
        when(draftPickRepository.existsByDraftAndPlayer(testDraft, aqua)).thenReturn(true); // Déjà pris
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.selectPlayer(marcel.getId(), testGame.getId(), aqua.getId()))
            .isInstanceOf(PlayerAlreadySelectedException.class);
    }
    
    // UC8.4 : Validation - Draft non actif
    @Test
    @DisplayName("UC8.4 - Ne devrait pas pouvoir sélectionner si le draft n'est pas actif")
    void shouldRejectIfDraftNotActive() {
        // Given
        testDraft.setStatus(Draft.Status.PAUSED);
        
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua));
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.selectPlayer(marcel.getId(), testGame.getId(), aqua.getId()))
            .isInstanceOf(InvalidDraftStateException.class)
            .hasMessageContaining("Le draft n'est pas actif");
    }
    
    // UC8.5 : Snake draft (ordre inversé aux rounds pairs)
    @Test
    @DisplayName("UC8.5 - Devrait respecter l'ordre snake draft au round 2")
    void shouldRespectSnakeDraftOrder() {
        // Given - Round 2, pick 1 (devrait être Sarah)
        testDraft.setCurrentRound(2);
        testDraft.setCurrentPick(1);
        
        when(userRepository.findById(sarah.getId())).thenReturn(Optional.of(sarah));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(rezon.getId())).thenReturn(Optional.of(rezon));
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(3)); // Sarah
        when(draftPickRepository.existsByDraftAndPlayer(testDraft, rezon)).thenReturn(false);
        when(draftPickRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(draftService.nextPick(any(), anyInt())).thenReturn(testDraft);
        
        // When
        DraftPickDto result = refactoredGameService.selectPlayer(sarah.getId(), testGame.getId(), rezon.getId());
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getPickerName()).isEqualTo("Sarah");
        assertThat(result.getRound()).isEqualTo(2);
    }
    
    // UC8.6 : Validation - Règles régionales
    @Test
    @DisplayName("UC8.6 - Ne devrait pas pouvoir sélectionner plus de joueurs EU que permis")
    void shouldRejectIfRegionLimitExceeded() {
        // Given - Ajouter une règle : max 2 joueurs EU
        GameRegionRule euRule = GameRegionRule.builder()
            .id(UUID.randomUUID())
            .game(testGame)
            .region(Player.Region.EU)
            .maxPlayers(2)
            .build();
        testGame.getRegionRules().add(euRule);
        
        // 2 joueurs EU déjà sélectionnés
        when(draftPickRepository.countByDraftAndPlayerRegion(testDraft, Player.Region.EU)).thenReturn(2L);
        
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua)); // EU player
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(0));
        when(draftPickRepository.existsByDraftAndPlayer(testDraft, aqua)).thenReturn(false);
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.selectPlayer(marcel.getId(), testGame.getId(), aqua.getId()))
            .isInstanceOf(RegionLimitExceededException.class)
            .hasMessageContaining("Limite de joueurs EU atteinte");
    }
    
    // Test d'intégration : Workflow complet d'une sélection
    @Test
    @DisplayName("Workflow complet - Sélection avec toutes les validations")
    void shouldCompleteFullSelectionWorkflow() {
        // Given
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua));
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(0));
        when(draftPickRepository.existsByDraftAndPlayer(testDraft, aqua)).thenReturn(false);
        when(draftPickRepository.save(any())).thenAnswer(i -> {
            DraftPick pick = i.getArgument(0);
            pick.setId(UUID.randomUUID());
            pick.setSelectionTime(LocalDateTime.now());
            return pick;
        });
        when(draftService.nextPick(testDraft, 4)).thenAnswer(i -> {
            Draft d = i.getArgument(0);
            d.setCurrentPick(2);
            return d;
        });
        
        // When
        DraftPickDto result = refactoredGameService.selectPlayer(marcel.getId(), testGame.getId(), aqua.getId());
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getPlayerId()).isEqualTo(aqua.getId());
        assertThat(result.getPickerId()).isEqualTo(marcel.getId());
        
        // Vérifications
        verify(draftPickRepository).save(any(DraftPick.class));
        verify(draftService).nextPick(testDraft, 4);
    }
    
    // Performance
    @Test
    @DisplayName("Performance - Devrait sélectionner un joueur en moins de 150ms")
    void shouldSelectPlayerQuickly() {
        // Given
        when(userRepository.findById(marcel.getId())).thenReturn(Optional.of(marcel));
        when(gameRepository.findById(testGame.getId())).thenReturn(Optional.of(testGame));
        when(draftRepository.findByGame(testGame)).thenReturn(Optional.of(testDraft));
        when(playerRepository.findById(aqua.getId())).thenReturn(Optional.of(aqua));
        when(gameParticipantRepository.findByGame(testGame)).thenReturn(participants);
        when(draftService.getCurrentPicker(testDraft, participants)).thenReturn(participants.get(0));
        when(draftPickRepository.existsByDraftAndPlayer(testDraft, aqua)).thenReturn(false);
        when(draftPickRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(draftService.nextPick(any(), anyInt())).thenReturn(testDraft);
        
        // When
        long startTime = System.currentTimeMillis();
        DraftPickDto result = refactoredGameService.selectPlayer(marcel.getId(), testGame.getId(), aqua.getId());
        long endTime = System.currentTimeMillis();
        
        // Then
        assertThat(result).isNotNull();
        assertThat(endTime - startTime).isLessThan(150);
    }
} 