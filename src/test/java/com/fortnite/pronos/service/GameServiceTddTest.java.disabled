package com.fortnite.pronos.service;

import com.fortnite.pronos.dto.CreateGameRequest;
import com.fortnite.pronos.dto.GameDto;
import com.fortnite.pronos.exception.InvalidGameRequestException;
import com.fortnite.pronos.exception.UserNotFoundException;
import com.fortnite.pronos.model.*;
import com.fortnite.pronos.repository.GameParticipantRepository;
import com.fortnite.pronos.repository.GameRegionRuleRepository;
import com.fortnite.pronos.repository.GameRepository;
import com.fortnite.pronos.repository.UserRepository;
import com.fortnite.pronos.util.TestDataBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.util.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Tests TDD pour GameService - Approche Red-Green-Refactor
 * Ces tests définissent le comportement attendu de createGame
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT) // Pour éviter UnnecessaryStubbingException
@DisplayName("Tests TDD - GameService.createGame()")
class GameServiceTddTest {

    @Mock
    private GameRepository gameRepository;
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private GameParticipantRepository gameParticipantRepository;
    
    @Mock
    private GameRegionRuleRepository gameRegionRuleRepository;
    
    @Mock
    private ValidationService validationService;
    
    @Mock
    private InvitationCodeService invitationCodeService;
    
    @InjectMocks
    private RefactoredGameService refactoredGameService;
    
    private User testUser;
    private CreateGameRequest validRequest;
    
    @BeforeEach
    void setUp() {
        // Créer un utilisateur de test valide
        testUser = TestDataBuilder.createThibaut();
        testUser.setId(UUID.randomUUID());
        
        // Créer une requête valide par défaut
        validRequest = TestDataBuilder.createValidGameRequest();
    }
    
    // UC1 : Création Basique
    @Test
    @DisplayName("UC1 - Devrait créer une game avec les informations minimales")
    void shouldCreateGameWithMinimalInfo() {
        // Given
        CreateGameRequest request = new CreateGameRequest();
        request.setName("Ma première game");
        request.setMaxParticipants(4);
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        // validateCreateGameRequest ne retourne rien (void) - il lance une exception si invalide
        when(invitationCodeService.generateUniqueCode()).thenReturn("ABC123");
        when(gameRepository.save(any(Game.class))).thenAnswer(invocation -> {
            Game game = invocation.getArgument(0);
            game.setId(UUID.randomUUID());
            return game;
        });
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        GameDto result = refactoredGameService.createGame(testUser.getId(), request);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getName()).isEqualTo("Ma première game");
        assertThat(result.getMaxParticipants()).isEqualTo(4);
        assertThat(result.getStatus()).isEqualTo(GameStatus.CREATING);
        assertThat(result.getCreatorId()).isEqualTo(testUser.getId());
        
        // Vérifier que le créateur est ajouté comme participant
        verify(gameParticipantRepository).save(argThat(participant -> 
            participant.getUser().equals(testUser) && 
            participant.getDraftOrder() == 1
        ));
    }
    
    // UC3.1 : Validation - Nom invalide
    @Test
    @DisplayName("UC3.1 - Devrait rejeter une game sans nom")
    void shouldRejectGameWithoutName() {
        // Given
        CreateGameRequest request = new CreateGameRequest();
        request.setName("");
        request.setMaxParticipants(4);
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        doThrow(new InvalidGameRequestException("Requête invalide"))
            .when(validationService).validateCreateGameRequest(any());
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.createGame(testUser.getId(), request))
            .isInstanceOf(InvalidGameRequestException.class)
            .hasMessageContaining("invalide");
    }
    
    // UC3.2 : Validation - Nombre de participants
    @Test
    @DisplayName("UC3.2 - Devrait rejeter une game avec trop peu de participants")
    void shouldRejectGameWithTooFewParticipants() {
        // Given
        CreateGameRequest request = new CreateGameRequest();
        request.setName("Game invalide");
        request.setMaxParticipants(1); // Minimum 2
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        doThrow(new InvalidGameRequestException("Requête invalide"))
            .when(validationService).validateCreateGameRequest(any());
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.createGame(testUser.getId(), request))
            .isInstanceOf(InvalidGameRequestException.class);
    }
    
    @Test
    @DisplayName("UC3.2 - Devrait rejeter une game avec trop de participants")
    void shouldRejectGameWithTooManyParticipants() {
        // Given
        CreateGameRequest request = new CreateGameRequest();
        request.setName("Game invalide");
        request.setMaxParticipants(11); // Maximum 10
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        doThrow(new InvalidGameRequestException("Requête invalide"))
            .when(validationService).validateCreateGameRequest(any());
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.createGame(testUser.getId(), request))
            .isInstanceOf(InvalidGameRequestException.class);
    }
    
    // UC4 : Code d'invitation
    @Test
    @DisplayName("UC4 - Devrait générer un code d'invitation unique")
    void shouldGenerateUniqueInvitationCode() {
        // Given
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        // validateCreateGameRequest ne retourne rien (void) - il lance une exception si invalide
        when(validationService.validateRegionRules(any())).thenReturn(true);
        when(invitationCodeService.generateUniqueCode()).thenReturn("ABC123");
        when(gameRepository.save(any(Game.class))).thenAnswer(invocation -> {
            Game game = invocation.getArgument(0);
            game.setId(UUID.randomUUID());
            return game;
        });
        when(gameRegionRuleRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        GameDto result = refactoredGameService.createGame(testUser.getId(), validRequest);
        
        // Then
        assertThat(result.getInvitationCode()).isNotNull();
        assertThat(result.getInvitationCode()).isEqualTo("ABC123");
    }
    
    // UC2 : Règles régionales
    @Test
    @DisplayName("UC2 - Devrait créer une game avec des règles régionales")
    void shouldCreateGameWithRegionRules() {
        // Given
        Map<Player.Region, Integer> regionRules = new HashMap<>();
        regionRules.put(Player.Region.EU, 4);   // Réduit de 7 à 4
        regionRules.put(Player.Region.NAW, 3);  // Réduit de 5 à 3
        regionRules.put(Player.Region.BR, 3);   // Reste à 3
        // Total : 10, exactement maxParticipants
        validRequest.setRegionRules(regionRules);
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        // validateCreateGameRequest ne retourne rien (void) - il lance une exception si invalide
        when(validationService.validateRegionRules(any())).thenReturn(true);
        when(invitationCodeService.generateUniqueCode()).thenReturn("ABC123");
        when(gameRepository.save(any(Game.class))).thenAnswer(invocation -> {
            Game game = invocation.getArgument(0);
            game.setId(UUID.randomUUID());
            return game;
        });
        when(gameRegionRuleRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        GameDto result = refactoredGameService.createGame(testUser.getId(), validRequest);
        
        // Then
        assertThat(result).isNotNull();
        
        // Vérifier que les règles régionales sont créées
        verify(gameRegionRuleRepository, times(3)).save(any(GameRegionRule.class));
        verify(gameRegionRuleRepository).save(argThat(rule -> 
            rule.getRegion() == Player.Region.EU && rule.getMaxPlayers() == 4
        ));
        verify(gameRegionRuleRepository).save(argThat(rule -> 
            rule.getRegion() == Player.Region.NAW && rule.getMaxPlayers() == 3
        ));
        verify(gameRegionRuleRepository).save(argThat(rule -> 
            rule.getRegion() == Player.Region.BR && rule.getMaxPlayers() == 3
        ));
    }
    
    // UC3.3 : Validation - Règles régionales invalides
    @Test
    @DisplayName("UC3.3 - Devrait rejeter des règles régionales invalides")
    void shouldRejectInvalidRegionRules() {
        // Given
        Map<Player.Region, Integer> invalidRules = new HashMap<>();
        invalidRules.put(Player.Region.EU, 0); // Invalide : minimum 1
        validRequest.setRegionRules(invalidRules);
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        // validateCreateGameRequest ne retourne rien (void) - il lance une exception si invalide
        when(validationService.validateRegionRules(any())).thenReturn(false);
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.createGame(testUser.getId(), validRequest))
            .isInstanceOf(InvalidGameRequestException.class)
            .hasMessageContaining("Règles régionales invalides");
    }
    
    // Cas d'erreur : Utilisateur non trouvé
    @Test
    @DisplayName("Devrait échouer si l'utilisateur n'existe pas")
    void shouldFailIfUserNotFound() {
        // Given
        UUID unknownUserId = UUID.randomUUID();
        when(userRepository.findById(unknownUserId)).thenReturn(Optional.empty());
        
        // When/Then
        assertThatThrownBy(() -> refactoredGameService.createGame(unknownUserId, validRequest))
            .isInstanceOf(UserNotFoundException.class)
            .hasMessageContaining("Utilisateur non trouvé");
    }
    
    // Test d'intégration : Workflow complet
    @Test
    @DisplayName("Workflow complet - Création avec tous les paramètres")
    void shouldCreateGameWithFullWorkflow() {
        // Given
        validRequest.setDescription("Game de test complète");
        validRequest.setIsPrivate(true);
        validRequest.setAutoStartDraft(false);
        validRequest.setDraftTimeLimit(600); // 10 minutes
        
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        // validateCreateGameRequest ne retourne rien (void) - il lance une exception si invalide
        when(validationService.validateRegionRules(any())).thenReturn(true);
        when(invitationCodeService.generateUniqueCode()).thenReturn("ABC123");
        when(gameRepository.save(any(Game.class))).thenAnswer(invocation -> {
            Game game = invocation.getArgument(0);
            game.setId(UUID.randomUUID());
            return game;
        });
        when(gameRegionRuleRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        GameDto result = refactoredGameService.createGame(testUser.getId(), validRequest);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getName()).isEqualTo(validRequest.getName());
        assertThat(result.getDescription()).isEqualTo(validRequest.getDescription());
        assertThat(result.getMaxParticipants()).isEqualTo(validRequest.getMaxParticipants());
        assertThat(result.getStatus()).isEqualTo(GameStatus.CREATING);
        assertThat(result.getInvitationCode()).isNotNull();
        
        // Vérifications des appels
        verify(gameRepository).save(any(Game.class));
        verify(gameParticipantRepository).save(any(GameParticipant.class));
        verify(gameRegionRuleRepository, times(2)).save(any(GameRegionRule.class)); // EU et NAW
    }
    
    // Test de performance
    @Test
    @DisplayName("Performance - Devrait créer une game en moins de 200ms")
    void shouldCreateGameUnder200ms() {
        // Given
        when(userRepository.findById(testUser.getId())).thenReturn(Optional.of(testUser));
        // validateCreateGameRequest ne retourne rien (void) - il lance une exception si invalide
        when(validationService.validateRegionRules(any())).thenReturn(true); // Ajout pour la validation des règles
        when(invitationCodeService.generateUniqueCode()).thenReturn("ABC123");
        when(gameRepository.save(any(Game.class))).thenAnswer(invocation -> {
            Game game = invocation.getArgument(0);
            game.setId(UUID.randomUUID());
            return game;
        });
        when(gameRepository.existsByInvitationCode(any())).thenReturn(false); // Pour la génération du code unique
        when(gameRegionRuleRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(gameParticipantRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        
        // When
        long startTime = System.currentTimeMillis();
        GameDto result = refactoredGameService.createGame(testUser.getId(), validRequest);
        long endTime = System.currentTimeMillis();
        
        // Then
        assertThat(result).isNotNull();
        assertThat(endTime - startTime).isLessThan(200);
    }
} 